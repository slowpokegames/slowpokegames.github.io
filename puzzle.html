<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Block Rolling Puzzle - Counters</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: sans-serif; color: white; }
        canvas { display: block; position: absolute; top: 0; left: 0; z-index: 0; }
        .screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(30, 30, 40, 0.95); display: none; flex-direction: column; align-items: center; justify-content: center; padding: 20px; box-sizing: border-box; z-index: 10; overflow-y: auto; }
        #gameScreen { background-color: transparent; padding: 0; justify-content: flex-start; align-items: stretch; z-index: 1; overflow: hidden; }
        #gameScreen > * { position: relative; }
        #gameCanvas { z-index: 1; width: 100%; height: 100%;}
        .screen h1, .screen h2 { color: #eee; text-shadow: 1px 1px 3px black; }
        .screen p { max-width: 600px; line-height: 1.6; text-align: center; color: #ccc; }
        .screen button, button.menu-button { background-color: #4466aa; color: white; border: none; padding: 12px 25px; font-size: 18px; cursor: pointer; border-radius: 5px; margin: 10px; transition: background-color 0.2s ease; box-shadow: 0 2px 5px rgba(0,0,0,0.3); }
        .screen button:hover, button.menu-button:hover { background-color: #5577cc; }
        .screen button.back-button { background-color: #777; position: absolute; top: 20px; left: 20px; z-index: 11; }
        .screen button.back-button:hover { background-color: #999; }
        #loadingScreen { display: flex; background-color: #2a3a4a; z-index: 100; transition: opacity 0.5s ease-out; }
        #loadingSpinner { border: 8px solid #f3f3f3; border-top: 8px solid #5577cc; border-radius: 50%; width: 60px; height: 60px; animation: spin 1s linear infinite; margin-bottom: 20px; }
        #loadingText { font-size: 24px; animation: pulse 1.5s ease-in-out infinite alternate; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        @keyframes pulse { 0% { opacity: 0.6; } 100% { opacity: 1; } }
        #mainMenu { /* Will be shown by JS */ }
        #levelSelectButtons { display: flex; flex-wrap: wrap; justify-content: center; gap: 15px; max-width: 80%; margin-top: 20px; }
        #levelSelectButtons button { padding: 10px; min-width: 80px; font-size: 16px; }
        #colorOptions { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; }
        .color-palette-button { min-width: 120px; }
        #designerContainer { display: flex; flex-direction: column; align-items: center; gap: 15px; width: 100%; max-width: 600px; }
        #designerTextarea { width: 80%; height: 200px; font-family: monospace; font-size: 14px; background-color: #111; color: #eee; border: 1px solid #555; padding: 10px; box-sizing: border-box; }
        #designerInfo { font-size: 14px; color: #aaa; text-align: left; width: 80%; }
        #uiContainer { position: absolute; top: 10px; left: 10px; right: 10px; display: none; justify-content: space-between; align-items: center; color: white; text-shadow: 1px 1px 2px black; pointer-events: none; z-index: 15; }
        #info { text-align: center; flex-grow: 1; font-size: 16px; margin: 0 10px; }
        /* Counter Styles */
        #counters { display: flex; gap: 15px; font-size: 16px; pointer-events: none; /* Pass clicks through */ position: absolute; top: 10px; right: 10px; background-color: rgba(0,0,0,0.3); padding: 5px 10px; border-radius: 5px;}
        #uiContainer button { pointer-events: all; padding: 5px 10px; font-size: 14px; cursor: pointer; background-color: #555; color: white; border: 1px solid #888; border-radius: 4px; margin: 0 5px; }
        #uiContainer button:disabled { background-color: #444; color: #888; cursor: not-allowed; }
        #winMessage, #finalMessage { z-index: 20; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0, 200, 0, 0.85); color: white; padding: 30px; border-radius: 10px; font-size: 24px; display: none; text-align: center; box-shadow: 0 0 15px rgba(0, 255, 0, 0.5); }
        #finalMessage { background-color: rgba(50, 50, 200, 0.85); font-size: 28px; padding: 40px; box-shadow: 0 0 15px rgba(50, 50, 255, 0.5); }
        #finalMessage button { padding: 10px 20px; font-size: 18px; margin-top: 15px; cursor: pointer; border: none; border-radius: 5px; background-color: #eee; color: #333; }
    </style>
</head>
<body>
    <!-- Screens (Unchanged HTML Structure) -->
    <div id="loadingScreen" class="screen"> <div id="loadingSpinner"></div> <div id="loadingText">Loading Blocks...</div> </div>
    <div id="mainMenu" class="screen"> <h1>Block Rolling Puzzle</h1> <button class="menu-button" onclick="showScreen('levelSelectScreen')">Start Game</button> <button class="menu-button" onclick="showScreen('designerScreen')">Level Designer</button> <button class="menu-button" onclick="showScreen('colorOptionsScreen')">Color Options</button> <button class="menu-button" onclick="showScreen('infoScreen')">About</button> </div>
    <div id="levelSelectScreen" class="screen"> <button class="back-button" onclick="showScreen('mainMenu')">&lt; Back</button> <h2>Select Level</h2> <div id="levelSelectButtons"></div> </div>
    <div id="colorOptionsScreen" class="screen"> <button class="back-button" onclick="showScreen('mainMenu')">&lt; Back</button> <h2>Color Options</h2> <p>Select a color palette. Changes apply on next level load/reset.</p> <div id="colorOptions"> <button class="color-palette-button" onclick="applyColorPalette('default')">Default</button> <button class="color-palette-button" onclick="applyColorPalette('deuteranopia')">Deuteranopia</button> <button class="color-palette-button" onclick="applyColorPalette('protanopia')">Protanopia</button> <button class="color-palette-button" onclick="applyColorPalette('tritanopia')">Tritanopia</button> <button class="color-palette-button" onclick="applyColorPalette('grayscale')">Grayscale</button> </div> </div>
    <div id="infoScreen" class="screen"> <button class="back-button" onclick="showScreen('mainMenu')">&lt; Back</button> <h1>About</h1> <p>This Block Rolling Puzzle game was generated iteratively with the help of an AI assistant.</p> <p>It features a 4x6 grid where the goal is typically to move the yellow 2x2x2 block from a starting position to a goal position by rolling it and other blocks around.</p> <p>Built using THREE.js for 3D rendering and TWEEN.js for animation, all packed into a single HTML file.</p> <p>Controls: Click and drag blocks to roll them. Click and drag the background to rotate/pan the camera. Use the mouse wheel to zoom.</p> </div>
    <div id="designerScreen" class="screen"> <button class="back-button" onclick="showScreen('mainMenu')">&lt; Back</button> <h2>Level Designer (Text Input)</h2> <div id="designerContainer"> <p>Define a 4x6 grid below. Use '.' for empty, lowercase for 1-high blocks, uppercase for 2-high blocks. The parser will find the unique 2x2x2 block automatically.</p> <textarea id="designerTextarea" spellcheck="false"> +----+ |....| |....| |.AA.| |.AA.| |b..c| |b..c| +----+</textarea> <div id="designerInfo"> Example: 'A' = 2x2x2, 'b' = 1x1x2 (standing), 'c'=1x1x2 (standing) <br/> (Game Y=0 is the bottom row) </div> <button class="menu-button" onclick="loadCustomLevel()">Load & Play Custom Level</button> <p id="designerError" style="color: #ff8888;"></p> </div> </div>

    <!-- Game Screen Wrapper -->
    <div id="gameScreen" class="screen">
        <div id="uiContainer">
            <button id="prevLevelBtn" onclick="goToPrevLevel()" disabled>&lt; Prev</button>
            <div id="info">Level 1: First Step</div>
            <button id="nextLevelBtn" onclick="goToNextLevel()">Next &gt;</button>
            <button id="menuBtn" onclick="showScreen('mainMenu')">Menu</button>
            <!-- *** NEW Counters Div *** -->
            <div id="counters">
                <span>Steps: <span id="stepCounter">0</span></span>
                <span>Moves: <span id="moveCounter">0</span></span>
            </div>
        </div>
        <div id="winMessage">Level Complete!</div>
        <div id="finalMessage"> Congratulations! All Levels Solved! <button onclick="resetGame()">Play Again From Start</button> </div>
        <canvas id="gameCanvas"></canvas>
    </div>


    <!-- ES Module Shims -->
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <!-- Import Map -->
    <script type="importmap"> { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/", "tween": "https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@21.0.0/dist/tween.esm.js" } } </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import * as TWEEN from 'tween';

        // --- Constants ---
        const GRID_WIDTH = 4; const GRID_HEIGHT = 6; const CELL_SIZE = 1.0;
        const BLOCK_VISUAL_GAP = 0.04; const FRAME_THICKNESS = 0.4; const FRAME_HEIGHT = 2.5;
        const DEFAULT_START_POS = { x: 1, y: 0 }; const DEFAULT_GOAL_POS = { x: 1, y: 4 };
        const BASE_COLORS = { '1,1,1': 0xff6666, '1,1,2': 0x66ff66, '1,2,2': 0x6666ff, '2,2,2': 0xffff66, 'frame': 0xaaaaaa, 'grid': 0x555555, 'start': 0x00cc00, 'goal': 0xcc0000 };
        const COLOR_PALETTES = { default: { ...BASE_COLORS }, deuteranopia: { ...BASE_COLORS, '1,1,1': 0xffb347, '1,1,2': 0x87cefa, '1,2,2': 0x6495ed, 'start': 0x00af00, 'goal': 0xff8c00 }, protanopia: { ...BASE_COLORS, '1,1,1': 0xffae42, '1,1,2': 0xadd8e6, '1,2,2': 0xb0c4de, 'start': 0x3cb371, 'goal': 0xffda03 }, tritanopia: { ...BASE_COLORS, '1,1,1': 0xff7f7f, '1,1,2': 0x00ffff, '1,2,2': 0xffc0cb, 'start': 0x32cd32, 'goal': 0xff1493 }, grayscale: { '1,1,1': 0xaaaaaa, '1,1,2': 0xcccccc, '1,2,2': 0x888888, '2,2,2': 0xeeeeee, 'frame': 0x777777, 'grid': 0x444444, 'start': 0x99ff99, 'goal': 0xff9999 } };
        let currentColors = { ...COLOR_PALETTES.default };
        const SOUNDS = { /* ... */ }; Object.assign(SOUNDS, { move: 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA', error: 'data:audio/wav;base64,UklGRlAAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAAABkYXRhFAAAAEB/QEB/QEB/QEB/QEB/QEB/QEB/QEB/QE=', win: 'data:audio/wav;base64,UklGRmAAAABXQVZFZm10IBAAAAABAAIAgLsAAAB3AQAEABAAZGF0YQIAAAAAAAAAP0A/QD9AQEBAQEA/QAAAAD9AAAAAAAAAP0AAAAAAAAAAAAAAAD9AP0A/QD9AP0AAAAAAAAAP0A/QAAAAAAAAAA=', complete: 'data:audio/wav;base64,UklGRnACAABXQVZFZm10IBAAAAABAAIAgLsAAAB3AQAEABAAZGF0YQQCAAD/AACAAIgA/wAAgACIAP8AAIAAiAD/AACAAIgAAAAAAAAAAP8AAIAAiAD/AACAAIgA/wAAgACIAIAAAAAAAAAAgAAAAAAAAACAAAAAAAAAAP8AAIAAiAD/AACAAIgA/wAAgACIAAAAAP8A' });
        const MIN_DRAG_THRESHOLD = 35;

        // --- Grid Parser ---
        function parseGridToLevelData(gridString) { /* ... (Same as previous) ... */ const allLines = gridString.trim().split('\n'); if (allLines.length < 3) { console.error("Invalid grid string: Too few lines."); return null; } const gameRows = allLines.slice(1, allLines.length - 1); const rows = gameRows.map(row => { if (row.length < 3 || !row.startsWith('|') || !row.endsWith('|')) { console.error("Invalid row format:", row); return null; } return row.slice(1, -1) }).filter(row => row !== null); if(rows.length !== GRID_HEIGHT) { console.error(`Grid height mismatch after parsing! Expected ${GRID_HEIGHT}, got ${rows.length}`); return null; } if (!rows[0] || rows[0].length !== GRID_WIDTH) { const gotWidth = rows[0] ? rows[0].length : 'undefined'; console.error(`Grid width mismatch! Expected ${GRID_WIDTH}, got ${gotWidth}`); return null; } const height = GRID_HEIGHT; const width = GRID_WIDTH; const visited = Array(height).fill(null).map(() => Array(width).fill(false)); const config = []; let goalBlockStartPos = null; let goalBlockFound = false; const dr = [-1, 1, 0, 0]; const dc = [0, 0, -1, 1]; for (let r = 0; r < height; r++) { for (let c = 0; c < width; c++) { const startChar = rows[r][c]; if (startChar === '.' || visited[r][c]) continue; const queue = [[r, c]]; visited[r][c] = true; let minX = c, maxX = c, minY = r, maxY = r; const currentBlockCells = []; while (queue.length > 0) { const [currR, currC] = queue.shift(); currentBlockCells.push([currR, currC]); minX = Math.min(minX, currC); maxX = Math.max(maxX, currC); minY = Math.min(minY, currR); maxY = Math.max(maxY, currR); for (let i = 0; i < 4; i++) { const nR = currR + dr[i]; const nC = currC + dc[i]; if (nR >= 0 && nR < height && nC >= 0 && nC < width && rows[nR][nC] === startChar && !visited[nR][nC]) { visited[nR][nC] = true; queue.push([nR, nC]); } } } const pieceWidth = maxX - minX + 1; const pieceDepth = maxY - minY + 1; const pieceHeight = (startChar >= 'A' && startChar <= 'Z') ? 2 : 1; const gameX = minX; const gameY = height - 1 - maxY; if (pieceWidth === 2 && pieceDepth === 2 && pieceHeight === 2) { if (goalBlockFound) { console.error("Invalid Puzzle: Multiple 2x2x2 blocks found!"); return null; } goalBlockFound = true; goalBlockStartPos = { x: gameX, y: gameY }; } else { config.push([[pieceWidth, pieceDepth, pieceHeight], { x: gameX, y: gameY }]); } } } if (!goalBlockFound) { console.error("Invalid Puzzle: No 2x2x2 goal block found!"); return null; } config.unshift([[2, 2, 2], goalBlockStartPos]); return { config: config, startPos: goalBlockStartPos }; }

        // --- Puzzle Definitions ---
        const puzzleLevelData = [ /* ... (Same puzzle definitions with themed names) ... */ { name: "First Step", config: [ [[2, 2, 2], DEFAULT_START_POS], [[1, 1, 1], { x: 1, y: 2 }], [[1, 1, 1], { x: 0, y: 5 }], ] }, { name: "The Detour", config: [ [[2, 2, 2], DEFAULT_START_POS], [[1, 1, 2], { x: 1, y: 2 }], [[1, 1, 1], { x: 3, y: 1 }], [[1, 1, 1], { x: 0, y: 4 }], ] }, { name: "Forced Route", config: [ [[2, 2, 2], DEFAULT_START_POS], [[1, 1, 2], { x: 1, y: 2 }], [[1, 1, 2], { x: 2, y: 2 }], [[1, 1, 1], { x: 0, y: 2 }], [[1, 1, 1], { x: 3, y: 2 }], [[1, 2, 2], { x: 0, y: 4 }], [[1, 2, 2], { x: 3, y: 4 }], ] }, { name: "Twin Obstacles", config: [ [[2, 2, 2], DEFAULT_START_POS], [[1, 1, 2], { x: 1, y: 2 }], [[1, 1, 2], { x: 2, y: 2 }], [[1, 1, 1], { x: 0, y: 3 }], [[1, 1, 1], { x: 3, y: 3 }], [[1, 2, 2], { x: 0, y: 0 }], [[1, 2, 2], { x: 3, y: 0 }], ] }, { name: "The Gauntlet", config: [ [[2, 2, 2], DEFAULT_START_POS], [[1, 2, 2], { x: 0, y: 0 }], [[1, 2, 2], { x: 3, y: 0 }], [[1, 2, 2], { x: 0, y: 2 }], [[1, 2, 2], { x: 3, y: 2 }], [[1, 1, 2], { x: 1, y: 2 }], [[1, 1, 2], { x: 2, y: 2 }], [[1, 1, 1], { x: 1, y: 4 }], [[1, 1, 1], { x: 2, y: 4 }], ] }, { name: "Walled In", grid: `+----+\n|.AA.|\n|B..C|\n|B..C|\n|dEEf|\n|gHHi|\n|gHHi|\n+----+` }, { name: "Narrow Squeeze", grid: `+----+\n|.AA.|\n|B..C|\n|B..C|\n|DeeF|\n|gHHi|\n|gHHi|\n+----+` }, { name: "Deep Blockade", grid: `+----+\n|abbc|\n|D..E|\n|D..E|\n|fGGh|\n|iJJk|\n|iJJk|\n+----+` }, { name: "Foundation Shift", grid: `+----+\n|abbc|\n|D..E|\n|D..E|\n|FGGH|\n|iJJk|\n|iJJk|\n+----+` }, { name: "Layer By Layer", grid: `+----+\n|ABBC|\n|A..C|\n|d..e|\n|fghi|\n|fJJi|\n|KJJL|\n+----+` }, { name: "Mixed Path", grid: `+----+\n|ABBC|\n|A..C|\n|d..e|\n|fGHi|\n|fJJi|\n|KJJL|\n+----+` }, { name: "Across the Board", grid: `+----+\n|..AA|\n|.BB.|\n|CC..|\n|ddee|\n|ffGG|\n|ffGG|\n+----+`, goalPos: { x: 0, y: 0 } }, { name: "The Long Way Home", grid: `+----+\n|AABC|\n|AAde|\n|fgHI|\n|fgjj|\n|k...|\n|kLL.|\n+----+`, goalPos: { x: 2, y: 0 } } ];
        const puzzleLevels = puzzleLevelData.map(levelData => { if (levelData.grid) { const parsed = parseGridToLevelData(levelData.grid); if (!parsed) { console.error(`Failed to parse level: ${levelData.name}`); return null; } return { ...levelData, ...parsed }; } else { if (!levelData.startPos) { const goalBlockEntry = levelData.config.find(entry => entry[0].join(',') === '2,2,2'); levelData.startPos = goalBlockEntry ? goalBlockEntry[1] : { ...DEFAULT_START_POS }; } return levelData; } }).filter(level => level !== null);


        // --- Global Variables ---
        let scene, camera, renderer, controls; let raycaster, pointer;
        let blocks = []; let gridState = [];
        let selectedBlock = null; let dragStartPos = null; let isDragging = false; let isAnimating = false;
        let audioContext; let soundBuffers = {}; let boardCenter = new THREE.Vector3();
        let currentLevelIndex = 0;
        let currentStartPos = { ...DEFAULT_START_POS }; let currentGoalPos = { ...DEFAULT_GOAL_POS };
        let startMarkerMesh = null; let goalMarkerMesh = null;
        let flashTimeoutId = null;
        let currentScreen = 'loadingScreen';
        let wallNMesh, wallSMesh, wallEMesh, wallWMesh;
        let gridHelperX, gridHelperZ;
        // *** NEW Counter Variables ***
        let stepCount = 0;
        let moveCount = 0;
        let lastMovedBlockId = null; // Use null to indicate no block moved yet


        // --- Block Class (Unchanged) ---
        class Block { /* ... */ constructor(id, dims, initialPos) { this.id = id; this.currentDims = [...dims]; this.position = { x: initialPos.x, y: initialPos.y }; this.baseDimsKey = [...dims].sort((a, b) => a - b).join(','); this.color = currentColors[this.baseDimsKey] || 0xffffff; /* Use currentColors */ this.isGoalBlock = (this.baseDimsKey === '2,2,2'); this.mesh = this.createMesh(); this.updateMeshPosition(); } createMesh() { const gap = BLOCK_VISUAL_GAP; const geomWidth = Math.max(0.01, this.currentDims[0] * CELL_SIZE - gap); const geomDepth = Math.max(0.01, this.currentDims[1] * CELL_SIZE - gap); const geomHeight = Math.max(0.01, this.currentDims[2] * CELL_SIZE - gap); const geometry = new THREE.BoxGeometry(geomWidth, geomHeight, geomDepth); const material = new THREE.MeshStandardMaterial({ color: this.color, roughness: 0.4, metalness: 0.1 }); const mesh = new THREE.Mesh(geometry, material); mesh.userData = { block: this }; mesh.castShadow = true; mesh.receiveShadow = true; return mesh; } getFootprint() { const cells = []; for (let i = 0; i < this.currentDims[0]; i++) { for (let j = 0; j < this.currentDims[1]; j++) { cells.push({ x: this.position.x + i, y: this.position.y + j }); } } return cells; } gridToWorld(gridX, gridY) { const worldX = (gridX * CELL_SIZE) - (GRID_WIDTH * CELL_SIZE / 2); const worldZ = (gridY * CELL_SIZE) - (GRID_HEIGHT * CELL_SIZE / 2); return { x: worldX, z: worldZ }; } updateMeshPosition() { const worldBase = this.gridToWorld(this.position.x, this.position.y); const centerBaseX = worldBase.x + (this.currentDims[0] * CELL_SIZE) / 2; const centerBaseZ = worldBase.z + (this.currentDims[1] * CELL_SIZE) / 2; const meshCenterY = (this.currentDims[2] * CELL_SIZE) / 2; this.mesh.position.set(centerBaseX, meshCenterY, centerBaseZ); this.mesh.rotation.set(0, 0, 0); this.mesh.quaternion.set(0, 0, 0, 1); } calculateRolledState(dx, dy) { /* ... (Correct Final Version) ... */ if (dx === 0 && dy === 0) return null; if (dx !== 0 && dy !== 0) return null; const newState = { position: { ...this.position }, currentDims: [...this.currentDims], newPivotWorld: new THREE.Vector3(), rotationAxis: new THREE.Vector3(), rotationAngle: Math.PI / 2, }; const worldBase = this.gridToWorld(this.position.x, this.position.y); const currentWidthWorld = this.currentDims[0] * CELL_SIZE; const currentDepthWorld = this.currentDims[1] * CELL_SIZE; if (dx === 1) {newState.position.x += this.currentDims[0]; [newState.currentDims[0], newState.currentDims[2]] = [this.currentDims[2], this.currentDims[0]]; newState.rotationAxis.set(0, 0, 1); newState.rotationAngle = -Math.PI / 2; newState.newPivotWorld.set( worldBase.x + currentWidthWorld, 0, worldBase.z + currentDepthWorld / 2 ); } else if (dx === -1) {newState.position.x -= this.currentDims[2]; [newState.currentDims[0], newState.currentDims[2]] = [this.currentDims[2], this.currentDims[0]]; newState.rotationAxis.set(0, 0, -1); newState.rotationAngle = -Math.PI / 2; newState.newPivotWorld.set( worldBase.x, 0, worldBase.z + currentDepthWorld / 2 ); } else if (dy === 1) {newState.position.y -= this.currentDims[2]; [newState.currentDims[1], newState.currentDims[2]] = [this.currentDims[2], this.currentDims[1]]; newState.rotationAxis.set(1, 0, 0); newState.rotationAngle = -Math.PI / 2; newState.newPivotWorld.set( worldBase.x + currentWidthWorld / 2, 0, worldBase.z ); } else if (dy === -1) {newState.position.y += this.currentDims[1]; [newState.currentDims[1], newState.currentDims[2]] = [this.currentDims[2], this.currentDims[1]]; newState.rotationAxis.set(-1, 0, 0); newState.rotationAngle = -Math.PI / 2; newState.newPivotWorld.set( worldBase.x + currentWidthWorld / 2, 0, worldBase.z + currentDepthWorld ); } newState.footprint = []; for (let i = 0; i < newState.currentDims[0]; i++) { for (let j = 0; j < newState.currentDims[1]; j++) { newState.footprint.push({ x: newState.position.x + i, y: newState.position.y + j }); } } return newState; } }

        // --- Screen Management (Unchanged) ---
        function showScreen(screenId) { document.querySelectorAll('.screen').forEach(screen => { screen.style.display = 'none'; }); const targetScreen = document.getElementById(screenId); if (targetScreen) { targetScreen.style.display = 'flex'; currentScreen = screenId; document.getElementById('uiContainer').style.display = (screenId === 'gameScreen') ? 'flex' : 'none'; renderer.domElement.style.display = (screenId === 'gameScreen') ? 'block' : 'none'; if(screenId !== 'gameScreen') controls.enabled = true; } else { console.error("Screen not found:", screenId); } }

        // --- Initialization (Unchanged Camera/Controls) ---
        function init() { /* ... (Standard setup as previous correct version) ... */ scene = new THREE.Scene(); scene.background = new THREE.Color(0x2a2a2a); const maxDim = Math.max(GRID_WIDTH, GRID_HEIGHT); scene.fog = new THREE.Fog(0x2a2a2a, maxDim * CELL_SIZE * 1.8, maxDim * CELL_SIZE * 4); const aspect = window.innerWidth / window.innerHeight; renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap; const ambientLight = new THREE.AmbientLight(0xffffff, 0.65); scene.add(ambientLight); const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9); directionalLight.position.set(GRID_WIDTH * CELL_SIZE * 0.4, maxDim * CELL_SIZE * 1.5, GRID_HEIGHT * CELL_SIZE * 0.6); directionalLight.castShadow = true; directionalLight.shadow.mapSize.width = 1024; directionalLight.shadow.mapSize.height = 1024; directionalLight.shadow.camera.near = 0.5; directionalLight.shadow.camera.far = maxDim * CELL_SIZE * 4; const shadowCamWidth = GRID_WIDTH * CELL_SIZE * 0.8; const shadowCamHeight = GRID_HEIGHT * CELL_SIZE * 0.8; directionalLight.shadow.camera.left = -shadowCamWidth; directionalLight.shadow.camera.right = shadowCamWidth; directionalLight.shadow.camera.top = shadowCamHeight; directionalLight.shadow.camera.bottom = -shadowCamHeight; scene.add(directionalLight); camera = new THREE.PerspectiveCamera(50, aspect, 0.2, 100 * CELL_SIZE); const initialCameraY = maxDim * CELL_SIZE * 1.7; camera.position.set(0, initialCameraY, 0.1); controls = new OrbitControls(camera, renderer.domElement); controls.enableRotate = true; controls.enableDamping = true; controls.dampingFactor = 0.1; controls.screenSpacePanning = false; controls.minPolarAngle = 0.1; controls.maxPolarAngle = Math.PI / 2 - 0.1; controls.enableZoom = true; boardCenter.set(0,0,0); controls.target.copy(boardCenter); camera.lookAt(controls.target); controls.update(); raycaster = new THREE.Raycaster(); pointer = new THREE.Vector2(); setupAudio(); createBoard(); populateLevelSelect(); const loadingScreen = document.getElementById('loadingScreen'); setTimeout(() => { loadingScreen.style.opacity = '0'; setTimeout(() => { loadingScreen.style.display = 'none'; showScreen('mainMenu'); }, 500); }, 1500); window.addEventListener('resize', onWindowResize); renderer.domElement.addEventListener('pointerdown', onPointerDown, false); renderer.domElement.addEventListener('pointermove', onPointerMoveBlock, false); renderer.domElement.addEventListener('pointerup', onPointerUp, false); renderer.domElement.addEventListener('pointercancel', onPointerUp, false); renderer.domElement.addEventListener('contextmenu', (event) => event.preventDefault()); renderer.domElement.style.cursor = 'grab'; animate(); }

        // --- Audio (Unchanged) ---
        function setupAudio() { /*...*/ try { audioContext = new (window.AudioContext || window.webkitAudioContext)(); if (audioContext.state === 'suspended') { handleAudioResume(); } loadSounds(); } catch (e) { console.warn("Web Audio API not supported.", e); audioContext = null; } }
        function handleAudioResume() { /*...*/ const resume = () => { audioContext.resume().then(() => { console.log("AudioContext resumed."); if (Object.keys(soundBuffers).length === 0) { loadSounds(); } }).catch(e => console.error("Error resuming AudioContext:", e)); }; document.body.addEventListener('click', resume, { once: true }); document.body.addEventListener('touchend', resume, { once: true }); }
        async function loadSounds() { /*...*/ if (!audioContext || audioContext.state !== 'running') { if (audioContext && audioContext.state !== 'closed') { console.log("AudioContext not running, deferring sound load."); } return; } for (const key in SOUNDS) { if (soundBuffers[key]) continue; try { const response = await fetch(SOUNDS[key]); if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`); const arrayBuffer = await response.arrayBuffer(); soundBuffers[key] = await audioContext.decodeAudioData(arrayBuffer); } catch (error) { console.error(`Error loading/decoding sound ${key}:`, error); } } }
        function playSound(key) { /*...*/ if (!audioContext || audioContext.state !== 'running' || !soundBuffers[key]) { return; } try { const source = audioContext.createBufferSource(); source.buffer = soundBuffers[key]; source.connect(audioContext.destination); source.start(0); } catch(e) { console.error(`Error playing sound ${key}:`, e); } }

        // --- Board Creation / Markers / Colors (Unchanged) ---
        function getMarkerWorldCenter(gridPos) { /*...*/ const worldBottomLeft = Block.prototype.gridToWorld(gridPos.x, gridPos.y); const markerCenterX = worldBottomLeft.x + CELL_SIZE; const markerCenterZ = worldBottomLeft.z + CELL_SIZE; return { x: markerCenterX, y: 0.02, z: markerCenterZ }; }
        function createBoard() { /*...*/ const boardWidth = GRID_WIDTH * CELL_SIZE; const boardHeight = GRID_HEIGHT * CELL_SIZE; const halfWidth = boardWidth / 2; const halfHeight = boardHeight / 2; const planeGeometry = new THREE.PlaneGeometry(boardWidth, boardHeight); const planeMaterial = new THREE.MeshStandardMaterial({ color: 0x444444, side: THREE.DoubleSide }); const plane = new THREE.Mesh(planeGeometry, planeMaterial); plane.rotation.x = -Math.PI / 2; plane.receiveShadow = true; scene.add(plane); gridHelperX = new THREE.GridHelper(boardWidth, GRID_WIDTH, currentColors.grid, currentColors.grid); gridHelperZ = new THREE.GridHelper(boardHeight, GRID_HEIGHT, currentColors.grid, currentColors.grid); gridHelperX.position.y = 0.01; gridHelperZ.position.y = 0.01; gridHelperZ.rotation.y = Math.PI / 2; scene.add(gridHelperX); scene.add(gridHelperZ); const frameMaterial = new THREE.MeshStandardMaterial({ color: currentColors.frame, roughness: 0.7 }); const frameWidthActual = boardWidth + 2 * FRAME_THICKNESS; const frameDepthActual = boardHeight + 2 * FRAME_THICKNESS; wallNMesh = new THREE.Mesh(new THREE.BoxGeometry(frameWidthActual, FRAME_HEIGHT, FRAME_THICKNESS), frameMaterial.clone()); wallNMesh.position.set(0, FRAME_HEIGHT / 2, -halfHeight - FRAME_THICKNESS / 2); wallNMesh.castShadow = true; wallNMesh.receiveShadow = true; scene.add(wallNMesh); wallSMesh = new THREE.Mesh(new THREE.BoxGeometry(frameWidthActual, FRAME_HEIGHT, FRAME_THICKNESS), frameMaterial.clone()); wallSMesh.position.set(0, FRAME_HEIGHT / 2, halfHeight + FRAME_THICKNESS / 2); wallSMesh.castShadow = true; wallSMesh.receiveShadow = true; scene.add(wallSMesh); wallEMesh = new THREE.Mesh(new THREE.BoxGeometry(FRAME_THICKNESS, FRAME_HEIGHT, frameDepthActual), frameMaterial.clone()); wallEMesh.position.set(halfWidth + FRAME_THICKNESS / 2, FRAME_HEIGHT / 2, 0); wallEMesh.castShadow = true; wallEMesh.receiveShadow = true; scene.add(wallEMesh); wallWMesh = new THREE.Mesh(new THREE.BoxGeometry(FRAME_THICKNESS, FRAME_HEIGHT, frameDepthActual), frameMaterial.clone()); wallWMesh.position.set(-halfWidth - FRAME_THICKNESS / 2, FRAME_HEIGHT / 2, 0); wallWMesh.castShadow = true; wallWMesh.receiveShadow = true; scene.add(wallWMesh); const markerGeom = new THREE.PlaneGeometry(2 * CELL_SIZE, 2 * CELL_SIZE); const startMat = new THREE.MeshBasicMaterial({ color: currentColors.start, transparent: true, opacity: 0.4, side: THREE.DoubleSide }); const goalMat = new THREE.MeshBasicMaterial({ color: currentColors.goal, transparent: true, opacity: 0.4, side: THREE.DoubleSide }); startMarkerMesh = new THREE.Mesh(markerGeom, startMat); startMarkerMesh.rotation.x = -Math.PI / 2; scene.add(startMarkerMesh); goalMarkerMesh = new THREE.Mesh(markerGeom, goalMat); goalMarkerMesh.rotation.x = -Math.PI / 2; scene.add(goalMarkerMesh); }
        function updateExistingColors() { if (wallNMesh) wallNMesh.material.color.setHex(currentColors.frame); if (wallSMesh) wallSMesh.material.color.setHex(currentColors.frame); if (wallEMesh) wallEMesh.material.color.setHex(currentColors.frame); if (wallWMesh) wallWMesh.material.color.setHex(currentColors.frame); if (startMarkerMesh) startMarkerMesh.material.color.setHex(currentColors.start); if (goalMarkerMesh) goalMarkerMesh.material.color.setHex(currentColors.goal); /* Grid helpers hard to update color */ blocks.forEach(block => { block.color = currentColors[block.baseDimsKey] || 0xffffff; if(block.mesh && block.mesh.material) { block.mesh.material.color.setHex(block.color); } }); }

        // --- Helper to Update Counter Display ---
        function updateUICounters() {
            const stepEl = document.getElementById('stepCounter');
            const moveEl = document.getElementById('moveCounter');
            if (stepEl) stepEl.textContent = stepCount;
            if (moveEl) moveEl.textContent = moveCount;
        }

        // --- Puzzle Setup / Level Loading (Reset Counters) ---
        function setupPuzzle(puzzleConfig, startPosOverride) { /*...*/ blocks.forEach(block => { if (block.mesh) scene.remove(block.mesh); }); blocks = []; gridState = Array(GRID_HEIGHT).fill(null).map(() => Array(GRID_WIDTH).fill(null)); document.getElementById('winMessage').style.display = 'none'; document.getElementById('finalMessage').style.display = 'none'; let blockIdCounter = 0; puzzleConfig.forEach(entry => { const [dims, pos] = entry; if (pos.x < 0 || pos.x >= GRID_WIDTH || pos.y < 0 || pos.y >= GRID_HEIGHT) { console.error(`Invalid initial position ${pos.x},${pos.y} in level config for dims ${dims}. Skipping block.`); return; } const isGoalBlock = (dims.join(',') === '2,2,2'); const actualPos = (isGoalBlock && startPosOverride) ? startPosOverride : pos; const block = new Block(blockIdCounter++, dims, actualPos); blocks.push(block); scene.add(block.mesh); const footprint = block.getFootprint(); let collision = false; footprint.forEach(cell => { if (isValidCell(cell.x, cell.y)) { if (gridState[cell.y][cell.x] !== null) { console.warn(`Setup Collision @ (${cell.x}, ${cell.y})`); collision = true; } gridState[cell.y][cell.x] = block.id; } else { console.error("Setup: Block footprint out of bounds:", block, cell); collision = true; } }); if (collision) { console.warn(`Block ${block.id} (${dims}) at (${actualPos.x},${actualPos.y}) caused overlap or went out of bounds.`); } }); }
        function loadLevel(index, isCustom = false, customConfig = null, customStart = null, customGoal = null) { /*...*/ if (!isCustom && (index < 0 || index >= puzzleLevels.length)) { console.error("Invalid level index:", index); return; } currentLevelIndex = index; let levelName = `Custom Level`; let levelConfig, levelStart, levelGoal; if(isCustom) { levelConfig = customConfig; levelStart = customStart || DEFAULT_START_POS; levelGoal = customGoal || DEFAULT_GOAL_POS; document.getElementById('prevLevelBtn').style.display = 'none'; document.getElementById('nextLevelBtn').style.display = 'none'; } else { const level = puzzleLevels[currentLevelIndex]; levelName = level.name; levelConfig = level.config; levelStart = level.startPos ? { ...level.startPos } : { ...DEFAULT_START_POS }; levelGoal = level.goalPos ? { ...level.goalPos } : { ...DEFAULT_GOAL_POS }; document.getElementById('prevLevelBtn').style.display = 'inline-block'; document.getElementById('nextLevelBtn').style.display = 'inline-block'; } currentStartPos = { ...levelStart }; currentGoalPos = { ...levelGoal }; console.log(`Loading ${isCustom ? levelName : `Level ${currentLevelIndex + 1}: ${levelName}`}`); updateExistingColors(); setupPuzzle(levelConfig, currentStartPos); if (startMarkerMesh) { const startWorldPos = getMarkerWorldCenter(currentStartPos); startMarkerMesh.position.set(startWorldPos.x, startWorldPos.y, startWorldPos.z); } if (goalMarkerMesh) { const goalWorldPos = getMarkerWorldCenter(currentGoalPos); goalMarkerMesh.position.set(goalWorldPos.x, goalWorldPos.y, goalWorldPos.z); } document.getElementById('info').textContent = isCustom ? levelName : `Level ${currentLevelIndex + 1}: ${levelName}`; if (!isCustom) { document.getElementById('prevLevelBtn').disabled = (currentLevelIndex === 0); document.getElementById('nextLevelBtn').disabled = (currentLevelIndex === puzzleLevels.length - 1); }
            // *** Reset Counters ***
            stepCount = 0; moveCount = 0; lastMovedBlockId = null;
            updateUICounters(); // Update display

            showScreen('gameScreen'); const maxDim = Math.max(GRID_WIDTH, GRID_HEIGHT); camera.position.set(0, maxDim * CELL_SIZE * 1.7, 0.1); controls.target.copy(boardCenter); controls.update(); }
        function populateLevelSelect() { const container = document.getElementById('levelSelectButtons'); container.innerHTML = ''; puzzleLevels.forEach((level, index) => { const btn = document.createElement('button'); btn.textContent = `${index + 1}. ${level.name}`; btn.onclick = () => loadLevel(index); container.appendChild(btn); }); }
        window.showScreen = showScreen; window.goToNextLevel = () => { if (currentLevelIndex < puzzleLevels.length - 1) { loadLevel(currentLevelIndex + 1); } }; window.goToPrevLevel = () => { if (currentLevelIndex > 0) { loadLevel(currentLevelIndex - 1); } }; window.resetGame = () => { loadLevel(0); }; window.resetPuzzle = () => { if (isAnimating) return; console.log(`Resetting Level ${currentLevelIndex + 1}`); loadLevel(currentLevelIndex); }; window.applyColorPalette = (paletteName) => { const palette = COLOR_PALETTES[paletteName]; if (palette) { console.log("Applying color palette:", paletteName); currentColors = { ...palette }; updateExistingColors(); } else { console.warn("Unknown color palette:", paletteName); } }; window.loadCustomLevel = () => { const gridString = document.getElementById('designerTextarea').value; const errorEl = document.getElementById('designerError'); errorEl.textContent = ''; try { const parsedData = parseGridToLevelData(gridString); if (parsedData) { console.log("Loading custom level:", parsedData); loadLevel(-1, true, parsedData.config, parsedData.startPos, DEFAULT_GOAL_POS); } else { errorEl.textContent = 'Error parsing grid definition. Check console for details.'; } } catch (e) { console.error("Error loading custom level:", e); errorEl.textContent = 'An unexpected error occurred. Check console.'; } };

        // --- Event Handlers (Unchanged) ---
        function onWindowResize() { /*...*/ camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        function getIntersectedBlock(clientX, clientY) { /*...*/ pointer.x = (clientX / window.innerWidth) * 2 - 1; pointer.y = -(clientY / window.innerHeight) * 2 + 1; raycaster.setFromCamera(pointer, camera); const blockMeshes = blocks.map(b => b.mesh).filter(mesh => !!mesh); if (blockMeshes.length === 0) return null; const intersects = raycaster.intersectObjects(blockMeshes); for (let i = 0; i < intersects.length; i++) { if (intersects[i].object.userData && intersects[i].object.userData.block) { return intersects[i].object.userData.block; } } return null; }
        function onPointerDown(event) { /*...*/ if (event.button !== 0) return; const intersectedBlock = getIntersectedBlock(event.clientX, event.clientY); if (intersectedBlock && !isAnimating) { selectedBlock = intersectedBlock; isDragging = true; dragStartPos = { x: event.clientX, y: event.clientY }; controls.enabled = false; selectedBlock.mesh.material.emissive.setHex(0x555555); renderer.domElement.style.cursor = 'grabbing'; } else { selectedBlock = null; isDragging = false; controls.enabled = true; renderer.domElement.style.cursor = 'grab'; } }
        function onPointerMoveBlock(event) { /*...*/ if (!isDragging || !selectedBlock || isAnimating) return; const currentPos = { x: event.clientX, y: event.clientY }; const dragVector = { x: currentPos.x - dragStartPos.x, y: currentPos.y - dragStartPos.y }; const dragDistance = Math.sqrt(dragVector.x ** 2 + dragVector.y ** 2); if (dragDistance > MIN_DRAG_THRESHOLD) { let dx = 0, dy = 0; if (Math.abs(dragVector.x) > Math.abs(dragVector.y)) { dx = Math.sign(dragVector.x); } else { dy = -Math.sign(dragVector.y); } const success = attemptRoll(selectedBlock, dx, dy); if (success) { dragStartPos = { x: event.clientX, y: event.clientY }; } } }
        function onPointerUp(event) { /* ... (Unchanged from previous) ... */ if (event.button !== 0) return; const blockThatWasSelected = selectedBlock; isDragging = false; selectedBlock = null; renderer.domElement.style.cursor = 'grab'; controls.enabled = true; if (blockThatWasSelected && blockThatWasSelected.mesh && blockThatWasSelected.mesh.material) { if (blockThatWasSelected.mesh.userData.flashTimeoutId) { clearTimeout(blockThatWasSelected.mesh.userData.flashTimeoutId); blockThatWasSelected.mesh.userData.flashTimeoutId = null; } blockThatWasSelected.mesh.material.emissive.setHex(0x000000); const originalColorHex = currentColors[blockThatWasSelected.baseDimsKey] || 0xffffff; blockThatWasSelected.mesh.material.color.setHex(originalColorHex); } }


        // --- Game Logic ---
        function isValidCell(x, y) { /*...*/ return x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT; }
        function isCellEmpty(x, y, blockToIgnoreId = -1) { /*...*/ if (!isValidCell(x, y)) return false; const occupantId = gridState[y][x]; return occupantId === null || occupantId === blockToIgnoreId; }
        function attemptRoll(block, dx, dy) { /*...*/ if (isAnimating) return false; const rolledState = block.calculateRolledState(dx, dy); if (!rolledState) { playSound('error'); return false; } let moveIsValid = true; for (const cell of rolledState.footprint) { if (!isValidCell(cell.x, cell.y) || !isCellEmpty(cell.x, cell.y, block.id)) { moveIsValid = false; break; } } if (moveIsValid) { isAnimating = true; block.getFootprint().forEach(cell => { if(isValidCell(cell.x, cell.y) && gridState[cell.y][cell.x] === block.id) { gridState[cell.y][cell.x] = null; } }); rolledState.footprint.forEach(cell => { gridState[cell.y][cell.x] = block.id; }); animateRoll(block, rolledState); return true; } else { flashMeshColor(block.mesh, 0xff0000, 250); playSound('error'); return false; } }

        // --- animateRoll (Increment Counters) ---
        function animateRoll(block, targetState) {
            const duration = 350; const pivotPoint = targetState.newPivotWorld; const pivot = new THREE.Group(); scene.add(pivot); pivot.position.copy(pivotPoint); const meshWorldPos = new THREE.Vector3(); block.mesh.getWorldPosition(meshWorldPos); const meshLocalPos = meshWorldPos.sub(pivotPoint); pivot.add(block.mesh); block.mesh.position.copy(meshLocalPos); const startRotation = { x: 0, y: 0, z: 0 }; const endRotation = { x: targetState.rotationAxis.x * targetState.rotationAngle, y: targetState.rotationAxis.y * targetState.rotationAngle, z: targetState.rotationAxis.z * targetState.rotationAngle };
            new TWEEN.Tween(startRotation).to(endRotation, duration).easing(TWEEN.Easing.Quadratic.Out)
                .onUpdate(() => { pivot.rotation.set(startRotation.x, startRotation.y, startRotation.z); })
                .onComplete(() => {
                    block.position = targetState.position; block.currentDims = targetState.currentDims;
                    pivot.remove(block.mesh); scene.remove(block.mesh);
                    block.mesh = block.createMesh(); block.updateMeshPosition(); scene.add(block.mesh);
                    scene.remove(pivot);
                    isAnimating = false; playSound('move');

                    // *** Increment and Update Counters ***
                    stepCount++;
                    if (block.id !== lastMovedBlockId) {
                        moveCount++;
                    }
                    lastMovedBlockId = block.id;
                    updateUICounters();
                    // *** End Counter Update ***

                    checkWinCondition();
                }).start();
         }
        function flashMeshColor(mesh, color, duration) { /* ... (Unchanged) ... */ if (!mesh || !mesh.material) return; if (mesh.userData.flashTimeoutId) { clearTimeout(mesh.userData.flashTimeoutId); mesh.userData.flashTimeoutId = null; } const originalColor = mesh.material.color.getHex(); const originalEmissive = mesh.material.emissive.getHex(); mesh.material.color.setHex(color); mesh.material.emissive.setHex(0x880000); mesh.userData.flashTimeoutId = setTimeout(() => { if (mesh && mesh.material && mesh.userData.block) { const currentBlock = mesh.userData.block; const isSelected = (selectedBlock === currentBlock); const baseColor = currentColors[currentBlock.baseDimsKey] || 0xffffff; mesh.material.color.setHex(baseColor); mesh.material.emissive.setHex(isSelected ? 0x555555 : 0x000000); } if(mesh.userData) mesh.userData.flashTimeoutId = null; }, duration); }
        function checkWinCondition() { /* ... (Unchanged) ... */ const goalBlock = blocks.find(b => b.isGoalBlock); if (!goalBlock) return false; if (goalBlock.position.x === currentGoalPos.x && goalBlock.position.y === currentGoalPos.y) { if (goalBlock.currentDims[0] === 2 && goalBlock.currentDims[1] === 2) { isAnimating = true; if (currentLevelIndex === puzzleLevels.length - 1 && currentScreen === 'gameScreen') { console.log("ALL LEVELS SOLVED!"); playSound('complete'); document.getElementById('finalMessage').style.display = 'block'; } else if (currentScreen === 'gameScreen') { console.log(`Level ${currentLevelIndex + 1} SOLVED!`); playSound('win'); document.getElementById('winMessage').textContent = "Level Complete!"; document.getElementById('winMessage').style.display = 'block'; setTimeout(() => { document.getElementById('winMessage').style.display = 'none'; goToNextLevel(); isAnimating = false; }, 1500); } else { console.log("Custom Level Solved!"); playSound('win'); document.getElementById('winMessage').textContent = "Custom Level Solved!"; document.getElementById('winMessage').style.display = 'block'; setTimeout(()=> {showScreen('mainMenu'); isAnimating = false;}, 2000); } return true; } } return false; }

        // --- Animation Loop (Standard) ---
        function animate(time) {
            requestAnimationFrame(animate);
            TWEEN.update(time);
            controls.update();
            renderer.render(scene, camera);
        }

        // --- Start ---
        boardCenter.set(0, 0, 0);
        init();

    </script>
</body>
</html>